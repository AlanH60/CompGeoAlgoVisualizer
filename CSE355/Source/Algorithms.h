#pragma once
#include "Primatives.h"

class App;
namespace D2D
{
	class Drawable;
	class Line;
	class Point;
}

class AlgorithmVisualizer
{
	public:
		//Indicates whether the visualizer is idle, running an algorithm, or finished.  
		//Results of an algorithm can be obtained when it is in a finished state.
		enum State
		{
			IDLE, //The no algorithm is running
			RUNNING, //Algorithm is running
			SLEEPING, //Algorithm is running, but the thread is currently sleeping
			FINISHED //Algorithm is done and result is ready to be queried by App.
		};
		enum ConvexHullAlgorithm
		{
			GRAHAM_SCAN,
			GIFT_WRAPPING,
			QUICK_HULL
		};
		enum TriangulationAlgorithm
		{
			EAR_CLIPPING
		};
	public:
		//EAR-CLIPPING: Contains the index of the previous vertex, next vertex, whether this vertex is an ear, and whether is has been clipped.
		struct VertexStatus
		{
			size_t prev = 0;
			size_t next = 0;
			bool isEar = false;
			bool isClipped = false;
		};
	public:
		AlgorithmVisualizer(App* pApp);
		~AlgorithmVisualizer();
		bool isIdle();
		bool isRunning();
		bool isFinished();
		bool isSleeping();
		bool shouldVisualize();
		float getSpeed();
		float* getSpeedPointer();
		void setVisualization(bool visualize);
		void setSpeed(float speed);
		void addSpeed(float modifier);
		std::vector<D2D::Line*>& getLines();
		std::vector<D2D::Point*>& getPoints();

		void computeConvexHull(std::vector<Vector2f>& points, ConvexHullAlgorithm algorithm = QUICK_HULL);
		void computeTriangulation(std::vector<Vector2f>& polygon, std::vector<std::pair<size_t, size_t>>& edges, TriangulationAlgorithm algorithm = EAR_CLIPPING);

		std::vector<std::pair<Vector2f, Vector2f>> getResult();
	private:
		//Clears all lines and points generated by the visualizer.
		void clear();
		//Pauses the thread for a specific time depending on the speed.
		void wait();
		void wait(float multiplier); //Waits for $multiplier times longer.
		//Convex Hull Algorithms
		static void convexHullGW(AlgorithmVisualizer* pVisualizer, std::vector<Vector2f>& points);
		static void convexHullGraham(AlgorithmVisualizer* pVisualizer, std::vector<Vector2f>& points);
		static void quickSort(std::vector<Vector2f>& points, std::vector<float>& dots, size_t start, size_t end);
		static size_t partition(std::vector<Vector2f>& points, std::vector<float>& dots, size_t start, size_t end);
		static void convexHullQuickHull(AlgorithmVisualizer* pVisualizer, std::vector<Vector2f>& points);
		static std::vector<Vector2f> quickHullHelper(AlgorithmVisualizer* pVisualizer, std::vector<Vector2f>& points, Vector2f left, Vector2f right);
		
		//Triangulation Algorithms
		static void triangulateEarClipping(AlgorithmVisualizer* pVisualizer, std::vector<Vector2f>& polygon);
		static bool diagonalCrossPolygon(std::vector<Vector2f>& polygon, Vector2f a, Vector2f b);
		static bool isEar(std::vector<Vector2f>& polygon, int idx, int prev, int next);

	private:
		App* pApp = nullptr;
		//Flag that indicates whether or not to perform an algorithm step by step.
		bool mVisualize = true;
		//State of the algorithm visualizer.
		State mState = IDLE;
		//Pointer to the thread that this algorithm will run on.
		std::thread* mThread = nullptr;
		//Speed of the algorithm.
		float mSpeed = 5;
		//Stores the lines that are generated from the algorithm visualizer.
		std::vector<D2D::Line*> mLines;
		//Stores the points that are generated from the algorithm visualizer.
		std::vector<D2D::Point*> mPoints;
		//Result of the algorithm
		std::vector<std::pair<Vector2f, Vector2f>> mResult;
};

//O(nh) where n = num of points, h = num of outputs
inline std::vector<Vector2f> convexHullGW(std::vector<Vector2f>& points)
{
	if (points.size() == 0)
		return std::vector<Vector2f>();
	int minY = 0;
	std::vector<Vector2f> convexHull = std::vector<Vector2f>();
	std::vector<bool> usedPoints = std::vector<bool>(points.size()); //True if point is used in convex hull(Wanted to use bitset, but size of points is unknown at compile time)
	convexHull.reserve(points.size());
	//Find point with smallest y value - O(n)
	for (int i = 0; i < points.size(); i ++)
	{
		int compareResult = compareY(points[minY], points[i]);
		if (compareResult > 0)
			minY = i;
		else if (compareResult == 0) //If same y, find leftmost point (smallest x value)
			minY = (points[minY].x > points[i].x) ? i : minY;
	}
	convexHull.push_back(points[minY]);
	usedPoints[minY] = true;
	int nextPoint = 0;
	//Find points on convex hull by "wrapping around" - O(nh)
	for (int i = 0; i < convexHull.size(); i++)
	{
		//Finds the rightmost point from the most recent vertex of convex hull. - O(n)
		for (int j = 0; j < points.size(); j++)
		{
			if (usedPoints[j])
				continue;
			if (!leftOf(convexHull[i], points[nextPoint] , points[j]))
				nextPoint = j;
		}
		//Done if the first vertex of convex hull is to the right of the rightmost unused point. (Done after h iterations)
		if (i != 0 && !leftOf(convexHull[i], points[nextPoint], convexHull[0])) 
			break;
		convexHull.push_back(points[nextPoint]);
		usedPoints[nextPoint] = true;
	}
	return convexHull;
}


inline size_t partition(std::vector<Vector2f>& points, std::vector<float>& dots, size_t start, size_t end)
{
	size_t i = start;
	for (size_t j = start; j < end; j++)
	{
		if (dots[j] >= dots[end - 1])
		{
			Vector2f temp = points[i];
			points[i] = points[j];
			points[j] = temp;
			float tempf = dots[i];
			dots[i] = dots[j];
			dots[j] = tempf;
			i++;
		}
	}
	return --i;
}

inline void quickSort(std::vector<Vector2f>& points, std::vector<float>& dots, size_t start, size_t end)
{
	if (end - start <= 1)
		return;

	size_t p = partition(points, dots, start, end);
	quickSort(points, dots, start, p);
	quickSort(points, dots, p + 1, end);
}

//Graham Scan- O(nlogn) - we choose an extreme point, pivot, that is guaranteed to be on the convex hull.
//Then we sort the points by angle from the pivot point, using dot product. 
//We can then use left tests and "wrap" the points in sorted counter-clockwise order.
inline std::vector<Vector2f> convexHullGraham(std::vector<Vector2f>& points)
{
	//Find the pivot point(Point with lowest y value, higher x value is used to break ties).  Rightmost of the bottommost
	int pivot = 0;
	for (int i = 0; i < points.size(); i++)
	{
		if (points[i].y < points[pivot].y)
			pivot = i;
		else if (points[i].y == points[pivot].y)
			pivot = (points[i].x > points[pivot].x) ? i : pivot;
	}

	//Get the dot products between the vector horizontal from pivot and the vector from pivot to any given point.
	//This dot product will be used to sort the points (1 -> -1).  
	std::vector<float> dots = std::vector<float>();
	for (int i = 0; i < points.size(); i++)
	{
		if (i == pivot) //Exclude the pivot point
			continue;
		dots.push_back(dot({ 1, 0 }, normalize(Vector2f{ points[i] - points[pivot] })));
	}
	std::vector<Vector2f> sortedPoints = points;
	sortedPoints.erase((pivot == 0) ? sortedPoints.begin() : std::next(sortedPoints.begin(), pivot));
	//Quick sort to sort vertices by dot product. Note: Average: O(nlogn), Worse: O(n^2), so this graham scan has worse case O(n^2).
	quickSort(sortedPoints, dots, 0, sortedPoints.size());

	//"Stack", but I use an array.
	std::vector<Vector2f> hull = std::vector<Vector2f>();
	hull.push_back(points[pivot]);
	hull.push_back(sortedPoints[0]);

	for (int i = 1; i < sortedPoints.size(); i ++)
	{
		if (leftOf(hull[hull.size() - 2], hull[hull.size() - 1], sortedPoints[i]))
			hull.push_back(sortedPoints[i]);
		else
		{
			//Remove from the end of the hull "stack" until the point satisfies the left test.
			do
			{
				hull.erase(--hull.end());
			} while (hull.size() > 2 && !leftOf(hull[hull.size() - 2], hull[hull.size() - 1], sortedPoints[i]));
			hull.push_back(sortedPoints[i]);
		}
	}
	return hull;
}

//Recursive function for quickHull
inline std::vector<Vector2f> quickHull(std::vector<Vector2f>& points, Vector2f left, Vector2f right)
{
	//Base case, no points remaining.
	if (points.empty())
		return std::vector<Vector2f>();
	Vector2f top;
	Vector2f leftRightUnit = normalize(Vector2f(right - left));
	float maxDist = 0;
	for (Vector2f& p : points)
	{
		Vector2f leftToP = p - left;
		//Projects the point p onto line from left to right.
		Vector2f projection = leftRightUnit * dot(leftToP, leftRightUnit);
		//From this projection, we take the y component from the vector from projection to point.
		float dist = abs((leftToP - projection).y);
		//Maximize this y component to find the next vertex of the hull.
		if (dist > maxDist)
		{
			maxDist = dist;
			top = p;
		}
	}
	//Once found we find the next vertex of the hull, top, we divide the points that are left of vector(left->c) and vector(c->right).
	std::vector<Vector2f> leftPoints;
	std::vector<Vector2f> rightPoints;
	for (Vector2f& p : points)
	{
		if (leftOf(left, top, p))
			leftPoints.push_back(p);
		else if (leftOf(top, right, p))
			rightPoints.push_back(p);
	}
	//Recursively find the hull of the points between left and top, and top and right.
	std::vector<Vector2f> leftHull = quickHull(leftPoints, left, top);
	std::vector<Vector2f> rightHull = quickHull(rightPoints, top, right);

	//Once we find the left and right hulls.  We combine them accordingly.
	std::vector<Vector2f> topHull;
	for (Vector2f& p : rightHull)
		topHull.push_back(p);
	topHull.push_back(top);
	for (Vector2f& p : leftHull)
		topHull.push_back(p);
	return topHull;
}

//Quick Hull- Average - O(nlogn), Worse - O(n^2)
inline std::vector<Vector2f> quickHull(std::vector<Vector2f>& points)
{
	Vector2f left = points[0];
	Vector2f right = points[0];
	//Find the top-leftmost point and the top-rightmost point.
	for (Vector2f& p : points)
	{
		if (p.x < left.x)
			left = p;
		else if (p.x == left.x)
			left = (p.y > left.y) ? p : left;
		if (p.x > right.x)
			right = p;
		else if (p.x == right.x)
			right = (p.y > right.y) ? p : right;
	}
	//Divide the points into a set of points above and below the line from the left to right points.
	std::vector<Vector2f> topPoints;
	std::vector<Vector2f> bottomPoints;
	for (Vector2f& p : points)
	{
		if (leftOf(left, right, p))
			topPoints.push_back(p);
		else if (p != left && p != right)
			bottomPoints.push_back(p);
	}
	//Find the top convex hull and bottom convex hull.
	std::vector<Vector2f> topHull = quickHull(topPoints, left, right);
	std::vector<Vector2f> bottomHull = quickHull(bottomPoints, right, left);

	//Combine the results of the top hull and bottom hull accordingly.
	std::vector<Vector2f> hull;
	hull.push_back(right);
	for (Vector2f& v : topHull)
		hull.push_back(v);
	hull.push_back(left);
	for (Vector2f& v : bottomHull)
		hull.push_back(v);
	return hull;
}

//Tests whether a diagonal crosses the polygon.  Only works with polygon diagonals, where a and b are vertices of the polygon.
inline bool diagonalCrossPolygon(std::vector<Vector2f>& polygon, Vector2f a, Vector2f b)
{
	for (int i = 1; i < polygon.size(); i++)
	{
		if (intersectProp(a, b, polygon[i - 1], polygon[i]))
		{
			return false;
		}
	}
	return true;
}

//O(n)
inline bool isEar(std::vector<Vector2f>& polygon, int idx, int prev, int next)
{
	if (!isConvex(polygon[prev], polygon[idx], polygon[next]))
		return false;
	return diagonalCrossPolygon(polygon, polygon[prev], polygon[next]);
}

//Contains the index of the previous vertex, next vertex, whether this vertex is an ear, and whether is has been clipped.
struct VertexStatus
{
	size_t prev = 0;
	size_t next = 0;
	bool isEar = false;
	bool isClipped = false;
};

//Ear-Clipping triangulation algorithm.  Cut off ears and update ear status of adjacent vertices.  Loop around the polygon until triangulation is done.
inline std::vector<std::pair<Vector2f, Vector2f>> triangulate(std::vector<Vector2f>& polygon)
{
	//Vector of diagonals
	std::vector<std::pair<Vector2f, Vector2f>> diagonals;
	//Vector of VertexStatus of each vertex of the polygon
	std::vector<VertexStatus> vertexStatus = std::vector<VertexStatus>(polygon.size());
	//Intialize the VertexStatus of each vertex - O(n^2)
	for (int i = 0; i < polygon.size(); i++)
		vertexStatus[i] = { (i == 0) ? (polygon.size() - 1) : i - 1, (i + 1) % polygon.size(), isEar(polygon, i, (i == 0) ? (polygon.size() - 1) : i - 1, (i + 1) % polygon.size()), false};

	int i = 0;
	while(diagonals.size() != (polygon.size() - 3)) //There are always n - 3 non-crossing diagonals.
	{
		i %= polygon.size();
		//If the vertex is an ear and is not already clipped, clip it.  Then update its prev and next vertices' ear status and their next and prev vertex respectively.
		if (!vertexStatus[i].isClipped && vertexStatus[i].isEar)
		{
			VertexStatus& v = vertexStatus[i];
			diagonals.push_back({ polygon[v.prev], polygon[v.next] });
			vertexStatus[v.prev].next = v.next;
			vertexStatus[v.next].prev = v.prev;
			vertexStatus[v.prev].isEar = isEar(polygon, v.prev, vertexStatus[v.prev].prev, v.next);
			vertexStatus[v.next].isEar = isEar(polygon, v.next, v.prev, vertexStatus[v.next].next);
			vertexStatus[i].isClipped = true;
		}
		i++;
	}

	return diagonals;
}