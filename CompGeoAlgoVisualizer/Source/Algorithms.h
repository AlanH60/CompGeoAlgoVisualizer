#pragma once
#include "Primatives.h"

class App;
namespace D2D
{
	class Drawable;
	class Line;
	class Point;
}

class AlgorithmVisualizer
{
	public:
		//Indicates whether the visualizer is idle, running an algorithm, or finished.  
		//Results of an algorithm can be obtained when it is in a finished state.
		enum State
		{
			IDLE, //The no algorithm is running
			RUNNING, //Algorithm is running
			SLEEPING, //Algorithm is running, but the thread is currently sleeping
			FINISHED //Algorithm is done and result is ready to be queried by App.
		};
		enum ConvexHullAlgorithm
		{
			GRAHAM_SCAN,
			GIFT_WRAPPING,
			QUICK_HULL
		};
		enum TriangulationAlgorithm
		{
			EAR_CLIPPING
		};
	public:
		//EAR-CLIPPING: Contains the index of the previous vertex, next vertex, whether this vertex is an ear, and whether is has been clipped.
		struct VertexStatus
		{
			size_t prev = 0;
			size_t next = 0;
			bool isEar = false;
			bool isClipped = false;
		};
	public:
		AlgorithmVisualizer(App* pApp);
		~AlgorithmVisualizer();
		bool isIdle();
		bool isRunning();
		bool isFinished();
		bool isSleeping();
		bool shouldVisualize();
		float getSpeed();
		float* getSpeedPointer();
		void setVisualization(bool visualize);
		void setSpeed(float speed);
		void addSpeed(float modifier);
		std::vector<D2D::Line*>& getLines();
		std::vector<D2D::Point*>& getPoints();

		void computeConvexHull(std::vector<Vector2f>& points, ConvexHullAlgorithm algorithm = QUICK_HULL);
		void computeTriangulation(std::vector<Vector2f>& polygon, std::vector<std::pair<int, int>>& edges, TriangulationAlgorithm algorithm = EAR_CLIPPING);

		std::vector<std::pair<Vector2f, Vector2f>> getResult();
	private:
		//Clears all lines and points generated by the visualizer.
		void clear();
		//Pauses the thread for a specific time depending on the speed.
		void wait();
		void wait(float multiplier); //Waits for $multiplier times longer.
		//Convex Hull Algorithms
		static void convexHullGW(AlgorithmVisualizer* pVisualizer, std::vector<Vector2f>& points);
		static void convexHullGraham(AlgorithmVisualizer* pVisualizer, std::vector<Vector2f>& points);
		static void quickSortAngle(std::vector<Vector2f>& points, std::vector<float>& dots, size_t start, size_t end);
		static size_t partition(std::vector<Vector2f>& points, std::vector<float>& dots, size_t start, size_t end);
		static void convexHullQuickHull(AlgorithmVisualizer* pVisualizer, std::vector<Vector2f>& points);
		static std::vector<Vector2f> quickHullHelper(AlgorithmVisualizer* pVisualizer, std::vector<Vector2f>& points, Vector2f left, Vector2f right);
		
		//Triangulation Algorithms
		static void triangulateEarClipping(AlgorithmVisualizer* pVisualizer, std::vector<Vector2f>& polygon);
		static bool diagonalCrossPolygon(std::vector<Vector2f>& polygon, Vector2f a, Vector2f b);
		static bool isEar(std::vector<Vector2f>& polygon, int idx, int prev, int next);

		static void triangulateSweep(AlgorithmVisualizer* pVisualizer, std::vector<Vector2f>& points, 
									 std::vector<std::pair<int,int>> edges);

	private:
		App* pApp = nullptr;
		//Flag that indicates whether or not to perform an algorithm step by step.
		bool mVisualize = true;
		//State of the algorithm visualizer.
		State mState = IDLE;
		//Pointer to the thread that this algorithm will run on.
		std::thread* mThread = nullptr;
		//Speed of the algorithm.
		float mSpeed = 5;
		//Stores the lines that are generated from the algorithm visualizer.
		std::vector<D2D::Line*> mLines;
		//Stores the points that are generated from the algorithm visualizer.
		std::vector<D2D::Point*> mPoints;
		//Result of the algorithm
		std::vector<std::pair<Vector2f, Vector2f>> mResult;
};

