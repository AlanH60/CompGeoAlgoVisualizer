#pragma once
#include "Primatives.h"
#include "DataStructs/Edge.h"
#include "DataStructs/DCEL.h"

class App;
namespace D2D
{
	class Drawable;
	class Line;
	class Point;
}

class AlgorithmVisualizer
{
	public:
		//Indicates whether the visualizer is idle, running an algorithm, or finished.  
		//Results of an algorithm can be obtained when it is in a finished state.
		enum class State
		{
			IDLE, //The no algorithm is running
			RUNNING, //Algorithm is running
			SLEEPING, //Algorithm is running, but the thread is currently sleeping
			FINISHED //Algorithm is done and result is ready to be queried by App.
		};
		enum class ConvexHullAlgorithm
		{
			GRAHAM_SCAN,
			GIFT_WRAPPING,
			QUICK_HULL
		};
		enum class TriangulationAlgorithm
		{
			EAR_CLIPPING,
			SWEEP
		};
	protected:
		//EAR-CLIPPING: Contains the index of the previous vertex, next vertex, whether this vertex is an ear, and whether is has been clipped.
		struct VertexStatus
		{
			size_t prev = 0;
			size_t next = 0;
			bool isEar = false;
			bool isClipped = false;
		};
		//Sweep algorithm
		//Comparison class used to sort points by greatest y-value.
		class VertexCompareY
		{
			public:
				//Return true if v1 has lesser y value than v2. X value used as tie breaker.
				bool operator()(const Vector2f& v1, const Vector2f& v2)
				{
					return v1.y < v2.y || (v1.y == v2.y && v1.x > v2.x);
				}
		};
		struct FortuneEvent
		{
			Vector2f point, left, center, right;
			bool isCircle;

			FortuneEvent(const Vector2f& point, bool isCircle = false) : point(point), isCircle(isCircle) {}

			FortuneEvent(const Vector2f& point, const Vector2f& left, const Vector2f& center, const Vector2f& right, bool isCircle = true)
				:
				point(point), left(left), center(center), right(right), isCircle(isCircle) {}
		};
		class FortuneEventCompare
		{
			public:
				//Return true if v1 has lesser y value than v2. X value used as tie breaker.
				bool operator()(const FortuneEvent& e1, const FortuneEvent& e2)
				{
					return e1.point.y < e2.point.y || (e1.point.y == e2.point.y && e1.point.x > e2.point.x);
				}
		};

	public:
		AlgorithmVisualizer(App* pApp);
		~AlgorithmVisualizer();
		/**
		* Check whether the algorithm visualizer is idle(No algorithm is running).
		* @returns true if no algorithm is running.
		*/
		bool isIdle();
		/**
		* Check whether the algorithm visualizer is running.
		* @returns true if algorithm visualizer is running.
		*/
		bool isRunning();
		/**
		* Check whether the algorithm visualizer is finished(Results can be obtained).
		* @returns true if algorithm visualizer is finished.
		*/
		bool isFinished();
		/**
		* Check whether the algorithm visualizer is sleeping(Running but thread is sleeping).
		* @returns true if algorithm visualizer is sleeping.
		*/
		bool isSleeping();
		/**
		* TODO: Flag whether the algorithm should produce visualization of the algorithm.
		*/
		bool shouldVisualize();

		/**
		* Set the should visualize flag
		* @param visualize the new value of the flag.
		*/
		void setVisualization(bool visualize);
		/**
		* Get the speed of the algorithm
		* @returns speed of the algorithm(1 - 10)
		*/
		float getSpeed();
		/**
		* Sets the speed of the algorithm.
		* @param speed new speed.
		*/
		void setSpeed(float speed);
		/**
		* Adds to the speed of the algorithm.
		* @param modifier value to add to speed.
		*/ 
		void addSpeed(float modifier);
		/**
		* Get the lines produced by the algorithm.
		* @returns vector of pointers to lines produced by the algorithm.
		*/
		std::vector<D2D::Line*>& getLines();
		/**
		* Get the points produced by the algorithm.
		* @returns vector of pointers to points produced by the algorithm.
		*/
		std::vector<D2D::Point*>& getPoints();

		/**
		* Starts the algorithm thread to compute the convex hull of a set of points.
		* @param points vector to the points.
		* @param algorithm convex hull algorithm to use.
		*/
		void computeConvexHull(std::vector<Vector2f>& points, ConvexHullAlgorithm algorithm = ConvexHullAlgorithm::QUICK_HULL);
		/**
		* Starts the algorithm thread to compute the triangulation of a polygon or PSLG.
		* @param polygon vector to the points.
		* @param edges vector of edges. (Used for PSLG)
		* @param algorithm triangulation algorithm to use.
		*/
		void computeTriangulation(std::vector<Vector2f>& polygon, std::unordered_map<Vector2f, std::vector<Vector2f>>& edges, TriangulationAlgorithm algorithm = TriangulationAlgorithm::EAR_CLIPPING);

		/**
		* Get the resulting edges/lines associated with the algorithm result.
		* @returns a vector of pairs of points.
		*/
		std::vector<Edge> getResult();
	private:
		//Clears all lines and points generated by the visualizer.
		void clear();
		//Pauses the thread for a specific time depending on the speed.
		void wait();
		void wait(float multiplier); //Waits for $multiplier times longer.
		//Convex Hull Algorithms
		static void convexHullGW(AlgorithmVisualizer* pVisualizer, std::vector<Vector2f>& points);
		static void convexHullGraham(AlgorithmVisualizer* pVisualizer, std::vector<Vector2f>& points);
		static void quickSortAngle(std::vector<Vector2f>& points, std::vector<float>& dots, size_t start, size_t end);
		static size_t partition(std::vector<Vector2f>& points, std::vector<float>& dots, size_t start, size_t end);
		static void convexHullQuickHull(AlgorithmVisualizer* pVisualizer, std::vector<Vector2f>& points);
		static std::vector<Vector2f> quickHullHelper(AlgorithmVisualizer* pVisualizer, std::vector<Vector2f>& points, Vector2f left, Vector2f right);
		
		//Triangulation Algorithms
		//Ear Clipping
		static void triangulateEarClipping(AlgorithmVisualizer* pVisualizer, std::vector<Vector2f>& polygon);
		static bool diagonalCrossPolygon(std::vector<Vector2f>& polygon, Vector2f a, Vector2f b);
		static bool isEar(std::vector<Vector2f>& polygon, int idx, int prev, int next);

		//Sweep
		static void triangulateSweep(AlgorithmVisualizer* pVisualizer, std::unordered_map<Vector2f, std::vector<Vector2f>>& edges);
		static void triangulateMonotoneMountain(AlgorithmVisualizer* pVisualizer, DCEL::Face* face);


		//Voronoi
		static void voronoiFortune(AlgorithmVisualizer* pVisualizer, std::vector<Vector2f>& points);
		static Vector2f getParabolicIntersection(const Vector2f& f1, const Vector2f& f2, float directrix);
		static Vector2f getCircleLowest(const Vector2f& v1, const Vector2f& v2, const Vector2f& v3);

	private:
		//Pointer to the application
		App* pApp = nullptr;
		//Flag that indicates whether or not to perform an algorithm step by step.
		bool mVisualize = true;
		//State of the algorithm visualizer.
		State mState = State::IDLE;
		//Pointer to the thread that this algorithm will run on.
		std::thread* mThread = nullptr;
		//Speed of the algorithm.
		float mSpeed = 5;
		//Stores the lines that are generated from the algorithm visualizer.
		std::vector<D2D::Line*> mLines;
		//Stores the points that are generated from the algorithm visualizer.
		std::vector<D2D::Point*> mPoints;
		//Result of the algorithm
		std::vector<Edge> mResult;
};

