#pragma once
#include "VoronoiDiagram.h"
class BeachLineStatus
{
	public:
		struct Arc;
		struct Event
		{
			Vector2f point; //Point where the directrix/sweepline should go to.
			Arc* arc; //If it is a circle event, pointer to the arc that should disappear.
			Vector2f center; //If it is a circle event, the center of the circle.
			bool isCircle; //Flag whether this event is a circle event.
			bool isValid = true; //Flag whether this is still a valid circle event.

			Event(const Vector2f& point) : point(point), isCircle(false) {}
			Event(Arc* arc, const Vector2f& point, const Vector2f& center) : arc(arc), point(point), center(center), isCircle(true) {}
		};
		class EventCompare
		{
			public:
				//Return true if v1 has greater y value than v2. X value used as tie breaker.
				bool operator()(const Event* e1, const Event* e2)
				{
					return LESSF(e1->point.y, e2->point.y) || (EQUALF(e1->point.y, e2->point.y) && GREATERF(e1->point.x, e2->point.x));
				}
		};
		struct Arc
		{
			Arc* parent = nullptr; //Parent arc in the tree
			Arc* left = nullptr; //Left child arc in the tree
			Arc* right = nullptr; //Right child arc in the tree
			bool isBlack = false; //Flag whether this arc is black or red- used for balancing

			Arc* prev = nullptr; //Arc to the left of this arc in the beachline
			Arc* next = nullptr; //Arc to the right of this arc in the beachline

			VoronoiDiagram::Face* face = nullptr; //The face that this arc is focused at.
			VoronoiDiagram::HalfEdge* leftEdge = nullptr; //The left edge generated by this arc and its prev arc.
			VoronoiDiagram::HalfEdge* rightEdge = nullptr; //The right edge genereated by this arc and its next arc.
			Event* circleEvent; //Its associated circle event.  Its current circle event is always valid.  When this arc encounters a new circle event, the old one is invalidated.

			~Arc();
		};

	public:
		BeachLineStatus(int directrixBegin) : mDirectrix(directrixBegin) {}
		~BeachLineStatus();
		/**
		* @returns number of elements in the tree.
		*/
		size_t getSize();
		/**
		* Inserts a new arc before a specific arc. The new arc will either be the arc's left child or its prev's right child.
		* @param arc the specific arc that the new arc is supposed to be before.
		* @param newArc the new arc to be inserted.
		*/
		void insertBefore(Arc* arc, Arc* newArc);
		/**
		* Inserts a new arc after a specific arc. The new arc will either be the arc's right child or its next's left child.
		* @param arc the specific arc that the new arc is supposed to be after.
		* @param newArc the new arc to be inserted.
		*/
		void insertAfter(Arc* arc, Arc* newArc);
		/**
		* Remove an element from the tree.
		* @param element - the element to be removed.
		* @returns True if element was successfully removed. False if the element doesn't exist in the tree.
		*/
		bool remove(Arc* arc, std::priority_queue<Event*, std::vector<Event*>, EventCompare>& eventQueue);

		/**
		* Sets the y coordinate of the directrix/sweepline.
		*/
		void setDirectrix(float directrix);

		/**
		* Adds the arc to the beachline and returns the pointer to the arc.
		* @returns pointer to the new arc.
		*/
		Arc* addArc(const Vector2f& site, std::priority_queue<Event*, std::vector<Event*>, EventCompare>& eventQueue);

		/**
		* Resolves the arc intersections that go to infinity at the end of the algorithm.
		*/
		void resolveLastArcs();
		/**
		* Returns the edges that make up the voronoi diagram. Should be called when algorithm is done(After resolve last arcs)
		* @returns vector of voronoi edges.
		*/
		std::vector<Edge> getEdges();

		/**
		* Returns the vector of pointers to half edges.  Used for visualization.
		*/
		std::vector<VoronoiDiagram::HalfEdge*>& getHalfEdgePtrs();

		/**
		* Gets the leftmost arc in the tree.
		* @returns leftmost arc in the tree.  nullptr if tree is empty.
		*/
		Arc* getLeftmostArc();
		
		/**
		* Updates all edges in the beach line.  Only used for visualization purposes.
		*/
		void updateEdges();
	protected:
		/**
		* Recursive function to remove an arc.
		* @param element - the element to be deleted.
		* @param arc - current arc to check for deletion
		* @returns True if element was successfully found and deleted. False if the element doesn't exist in the tree.
		*/
		bool __remove(Arc* arc, std::priority_queue<Event*, std::vector<Event*>, EventCompare>& eventQueue, bool dealloc = true);
		/**
		* Finds the leftmost child in the arc's right subtree.
		* @param arc arc in question.
		* @returns arc of the successor or nullptr if inputted arc has no right child.
		*/
		Arc* findSuccessor(Arc* arc);
		/**
		* Recursive function used to find the successor of an arc.
		* @param arc current arc.
		* @returns arc of the successor.
		*/
		Arc* __findSuccessor(Arc* arc);

		/**
		* Finds the rightmost child in the arc's left subtree.
		* @param arc arc in question.
		* @returns arc of the predecessor or nullptr if inputted arc has no left child.
		*/
		Arc* findPredecessor(Arc* arc);
		/**
		* Recursive function used to find the predecessor of an arc.
		* @param arc current arc.
		* @returns arc of the predecessor.
		*/
		Arc* __findPredecessor(Arc* arc);

		/**
		* Validates the tree after an insertion has occurred.
		* @param arc the newly inserted arc.
		*/
		void validateTreePostInsertion(Arc* arc);

		/**
		* Validates the tree after a deletion has occurred.
		* This method is only necessary if the deleted arc isn't pRoot and the deleted arc and the arc replacing that arc is black
		* (If replacing arc is red, we can change it to black.  If deleted arc is red, it doesn't change the black height of the tree)
		* @param parent parent arc of the deleted arc
		* @param isLeft flag whether the deleted arc was the left child of the parent.
		*/
		void validatePostDeletion(Arc* parent, bool isLeft);
		/**
		* Perform an LL Rotation on the subtree centered at the inputted parent arc.
		*
		*						  WHERE ( 1 ) is PARENT
		*					( 0 )						( 1 )
		*					/	\						/	\
		*				 ( 1 ) ( 2 )   ========>	 ( 3 ) ( 0 )
		*				  /		  							  \
		*			    ( 3	)	 							 ( 2 )
		*
		* @param parent the parent arc that the rotation will be centered around.
		*/
		void LLRotation(Arc* parent);

		/**
		* Perform an RR Rotation on the subtree centered at the inputted parent arc.
		*
		*						  WHERE ( 2 ) is PARENT
		*					( 0 )						( 2 )
		*					/	\						/	\
		*				 ( 1 ) ( 2 )   ========>	 ( 0 ) ( 3 )
		*						  \					  /
		*						 ( 3 )			   ( 1 )
		*
		* @param parent the parent arc that the rotation will be centered around.
		*/
		void RRRotation(Arc* parent);
		/**
		* Perform an LR Rotation on the subtree centered at the inputted parent arc.
		*
		*						  WHERE ( 1 ) is PARENT
		*					( 0 )						( 0 )
		*					/	\						/	\
		*				 ( 1 ) ( 2 )   ========>	 ( 3 ) ( 2 )
		*				    \		  				  /
		*				   ( 3 )	 			   ( 1 )
		*
		* @param parent the parent arc that the rotation will be centered around.
		*/
		void LRRotation(Arc* parent);
		/**
		* Perform an RL Rotation on the subtree centered at the inputted parent arc.
		*
		*						  WHERE ( 2 ) is PARENT
		*					( 0 )						( 0 )
		*					/	\						/	\
		*				 ( 1 ) ( 2 )   ========>	 ( 1 ) ( 3 )
		*						/		  					  \
		*					 ( 3 )	 						 ( 2 )
		*
		* @param parent the parent arc that the rotation will be centered around.
		*/
		void RLRotation(Arc* parent);

		/**
		* Gets the interesection between two arcs.
		* @param arc1 pointer to the first arc.
		* @param arc2 pointer to the second arc.
		* @returns the two intersections as a Vector2f.  If there is only 1 intersection, then the second float value is NaN.
		*/
		Vector2f getArcIntersection(Arc* arc1, Arc* arc2);
		/**
		* Given an x-value, this function returns the y-coordinate of the point that lies on (x, y) of the parabolic arc.
		* @param arc pointer to the arc.
		* @param x the x-value in question.
		* @returns y-coordinate of the point on the arc at that given x-coordinate.
		*/
		float getY(Arc* arc, float x);
		/**
		* Given an arc, allocates a NEW circle event for the arc.
		* @param arc pointer to the arc.
		* @returns pointer to the circle event.  nullptr if no valid circle event exists for the arc.
		*/
		Event* getCircleEvent(Arc* arc);
		/*
		* Returns the x-coordinate of the arc's left bound.
		* @returns x-coordinate of the arc's left bound.
		*/
		float getLeftX(Arc* arc);
		/*
		* Returns the x-coordinate of the arc's right bound.
		* @returns x-coordinate of the arc's right bound.
		*/
		float getRightX(Arc* arc);
	private:
		Arc* pRoot = nullptr;
		size_t mSize = 0;
		//Y-coordinate of directrix/sweepline.
		float mDirectrix;
		//VoronoiDiagram that this beach line will build.
		VoronoiDiagram mVoronoi;
		//Vector of pointers to half edges.  Used for visualization.
		std::vector<VoronoiDiagram::HalfEdge*> mHalfEdgePtrs;
};

